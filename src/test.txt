

typedef struct TEST_STATE {
  int a, b, c;
} TEST_STATE;

component *texts(TEST_STATE init) {
  return COMPONENT_EXTEND(COMPONENT_DEFAULTS, TEXT_DEFAULTS, .state = &init);
}

typedef struct sprops {
  struct base *children;
} sprops;

typedef struct sstate {
  int x;
  int y;
} aa_state;

typedef struct sstate {
  int z;
  int zas;
} bb_state;

typedef struct saa {
  sprops _props;
  aa_state _state;
} aa;

typedef struct sbb {
  sprops _props;
  bb_state _state;
} bb;

#define PROPS(...)                                                             \
  { .children = 0, __VA_ARGS__ }
#define STATE(...)                                                             \
  { __VA_ARGS__ }

#define ELEM_ALLOC(elem_type, props, state)                                    \
  ({                                                                           \
    elem_type *e = malloc(sizeof(elem_type));                                  \
    e->_props = (sprops)props;                                                 \
    e->_state = (elem_type##_state)state;                                      \
    e;                                                                         \
  })

#define ELEM(elem_type, props, state)                                          \
  {._state = (aa_state)state, ._props = (sprops)props};

---

  aa *elem1 = ELEM_ALLOC(aa, PROPS(.children = 0), STATE(.x = 0));
  bb *elem2 = ELEM_ALLOC(bb, PROPS(.children = 0), STATE(.z = 0));

  aa elem = {._state = (aa_state){.x = 1}, ._props = (sprops){.children = 0}};
  aa belem = ELEM(aa, PROPS(.children = 0), STATE(.x = 0));

  // component *a = texts((TEST_STATE){.a = 1});



--


#define PI 3.14159

float linear(float t, float b, float c, float d) { return c * t / d + b; }
float elastic(float t, float b, float c, float d) {
  if (t == 0)
    return b;
  if ((t /= d) == 1)
    return b + c;
  float p = d * .3f;
  float a = c;
  float s = p / 4;
  float postFix =
      a *
      pow(2,
          10 * (t -= 1)); // this is a fix, again, with post-increment operators
  return -(postFix * sin((t * d - s) * (2 * PI) / p)) + b;
}

float easeOut(float t, float b, float c, float d) {
  t /= d;
  return -c * t * (t - 2) + b;
};

int map[12][25] = {
    {1, 1, 2, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0},
    {1, 0, 0, 0, 2, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1},
    {1, 1, 2, 1, 2, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0},
    {1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1},
    {1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1},
    {0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0},
    {1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1},
    {1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 2, 1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1},
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1},
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1},
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1},
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1},
};

void screen_render(component *this) {
  /*
window_props *props = (window_props *)this->props;

int scale = 1;
int offsetx =
((this->rect.w / scale) / 2) - 16 + sin(props->passed / 5000.0) * 600;
int offsety =
((this->rect.h / scale) / 2) - 16 + sin(props->passed / 5000.0) * 300;

int blockw = 32;
int blockh = 32;
int bw = blockw;
// easeOut(props->passed, 0, blockw, frametime / 2);
int bh = blockh;
// easeOut(props->passed, 0, blockh, frametime / 2);
int cell_offset_x = blockw / 2;
int cell_offset_y = blockh / 4;

for (int frame = 0; frame < 8; frame++) {
for (int y = 0; y < 5; y++) {
for (int x = 0; x < 5; x++) {
  int cell = map[frame][x + (y * 5)];
  if (cell > 0) {
    int px = offsetx + (cell_offset_x * x - y * cell_offset_x) +
             (frame * 7 * cell_offset_x);
    int py = (offsety + ((x + y) * cell_offset_y) - blockh) +
             (frame * 7 * cell_offset_y);
    SDL_Rect dstrect = {px * scale, py * scale, bw * scale, bh * scale};
    SDL_Rect source = {(cell - 1) * blockw, 0, blockw, blockh};
    SDL_RenderCopy(props->renderer, props->texture, &source, &dstrect);
  }
}
}
}
*/
  component_render_children(this);
}
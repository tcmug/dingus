#ifndef MATRIXTEMPLATE_HPP
#define MATRIXTEMPLATE_HPP

#include "vectortemplate.hpp"

template <typename type>
class MatrixTemplate {
	public:

		typedef type ValueType;
		typedef MatrixTemplate <type> ClassType;

		union {
			ValueType values[4][4];
			ValueType TW_Matrix[16];
		};

		MatrixTemplate() {
			this->identity();
		}

		/*
		 * Load an identity math::TW_Vector3
		 */
		void identity() {
			this->TW_Matrix[0] = 1;
			this->TW_Matrix[1] = 0;
			this->TW_Matrix[2] = 0;
			this->TW_Matrix[3] = 0;

			this->TW_Matrix[4] = 0;
			this->TW_Matrix[5] = 1;
			this->TW_Matrix[6] = 0;
			this->TW_Matrix[7] = 0;

			this->TW_Matrix[8] = 0;
			this->TW_Matrix[9] = 0;
			this->TW_Matrix[10] = 1;
			this->TW_Matrix[11] = 0;

			this->TW_Matrix[12] = 0;
			this->TW_Matrix[13] = 0;
			this->TW_Matrix[14] = 0;
			this->TW_Matrix[15] = 1;
		}

		/*
		 * TW_Matrix multiplication
		 */
		ClassType operator * (const ClassType &other) const {

			ClassType result;

			result.TW_Matrix[0] = this->TW_Matrix[0]*other.TW_Matrix[0] + this->TW_Matrix[4]*other.TW_Matrix[1] + this->TW_Matrix[8]*other.TW_Matrix[2] + this->TW_Matrix[12]*other.TW_Matrix[3];
			result.TW_Matrix[1] = this->TW_Matrix[1]*other.TW_Matrix[0] + this->TW_Matrix[5]*other.TW_Matrix[1] + this->TW_Matrix[9]*other.TW_Matrix[2] + this->TW_Matrix[13]*other.TW_Matrix[3];
			result.TW_Matrix[2] = this->TW_Matrix[2]*other.TW_Matrix[0] + this->TW_Matrix[6]*other.TW_Matrix[1] + this->TW_Matrix[10]*other.TW_Matrix[2] + this->TW_Matrix[14]*other.TW_Matrix[3];
			result.TW_Matrix[3] = this->TW_Matrix[3]*other.TW_Matrix[0] + this->TW_Matrix[7]*other.TW_Matrix[1] + this->TW_Matrix[11]*other.TW_Matrix[2] + this->TW_Matrix[15]*other.TW_Matrix[3];

			result.TW_Matrix[4] = this->TW_Matrix[0]*other.TW_Matrix[4] + this->TW_Matrix[4]*other.TW_Matrix[5] + this->TW_Matrix[8]*other.TW_Matrix[6] + this->TW_Matrix[12]*other.TW_Matrix[7];
			result.TW_Matrix[5] = this->TW_Matrix[1]*other.TW_Matrix[4] + this->TW_Matrix[5]*other.TW_Matrix[5] + this->TW_Matrix[9]*other.TW_Matrix[6] + this->TW_Matrix[13]*other.TW_Matrix[7];
			result.TW_Matrix[6] = this->TW_Matrix[2]*other.TW_Matrix[4] + this->TW_Matrix[6]*other.TW_Matrix[5] + this->TW_Matrix[10]*other.TW_Matrix[6] + this->TW_Matrix[14]*other.TW_Matrix[7];
			result.TW_Matrix[7] = this->TW_Matrix[3]*other.TW_Matrix[4] + this->TW_Matrix[7]*other.TW_Matrix[5] + this->TW_Matrix[11]*other.TW_Matrix[6] + this->TW_Matrix[15]*other.TW_Matrix[7];

			result.TW_Matrix[8] = this->TW_Matrix[0]*other.TW_Matrix[8] + this->TW_Matrix[4]*other.TW_Matrix[9] + this->TW_Matrix[8]*other.TW_Matrix[10] + this->TW_Matrix[12]*other.TW_Matrix[11];
			result.TW_Matrix[9] = this->TW_Matrix[1]*other.TW_Matrix[8] + this->TW_Matrix[5]*other.TW_Matrix[9] + this->TW_Matrix[9]*other.TW_Matrix[10] + this->TW_Matrix[13]*other.TW_Matrix[11];
			result.TW_Matrix[10] = this->TW_Matrix[2]*other.TW_Matrix[8] + this->TW_Matrix[6]*other.TW_Matrix[9] + this->TW_Matrix[10]*other.TW_Matrix[10] + this->TW_Matrix[14]*other.TW_Matrix[11];
			result.TW_Matrix[11] = this->TW_Matrix[3]*other.TW_Matrix[8] + this->TW_Matrix[7]*other.TW_Matrix[9] + this->TW_Matrix[11]*other.TW_Matrix[10] + this->TW_Matrix[15]*other.TW_Matrix[11];

			result.TW_Matrix[12] = this->TW_Matrix[0]*other.TW_Matrix[12] + this->TW_Matrix[4]*other.TW_Matrix[13] + this->TW_Matrix[8]*other.TW_Matrix[14] + this->TW_Matrix[12]*other.TW_Matrix[15];
			result.TW_Matrix[13] = this->TW_Matrix[1]*other.TW_Matrix[12] + this->TW_Matrix[5]*other.TW_Matrix[13] + this->TW_Matrix[9]*other.TW_Matrix[14] + this->TW_Matrix[13]*other.TW_Matrix[15];
			result.TW_Matrix[14] = this->TW_Matrix[2]*other.TW_Matrix[12] + this->TW_Matrix[6]*other.TW_Matrix[13] + this->TW_Matrix[10]*other.TW_Matrix[14] + this->TW_Matrix[14]*other.TW_Matrix[15];
			result.TW_Matrix[15] = this->TW_Matrix[3]*other.TW_Matrix[12] + this->TW_Matrix[7]*other.TW_Matrix[13] + this->TW_Matrix[11]*other.TW_Matrix[14] + this->TW_Matrix[15]*other.TW_Matrix[15];

			return result;
		}

		/*
		 * Rotate TW_Matrix around its axes
		 */
		void rotate(ValueType psi, ValueType theta, ValueType phi) {
			ValueType ca = cos(phi), sa = sin(phi);
			ValueType cb = cos(theta), sb = sin(theta);
			ValueType cy = cos(psi), sy = sin(psi);

			this->TW_Matrix[0] = ca*cb;
			this->TW_Matrix[4] = ca*sb*sy - sa*cy;
			this->TW_Matrix[8] = ca*sb*cy + sa*sy;
			this->TW_Matrix[12] = 0.0;

			this->TW_Matrix[1] = sa*cb;
			this->TW_Matrix[5] = sa*sb*sy + ca*cy;
			this->TW_Matrix[9] = sa*sb*cy - ca*sy;
			this->TW_Matrix[13] = 0.0;

			this->TW_Matrix[2] = -sb;
			this->TW_Matrix[6] = cb*sy;
			this->TW_Matrix[10] = cb*cy;
			this->TW_Matrix[14] = 0.0;

			this->TW_Matrix[3] = 0.0;
			this->TW_Matrix[7] = 0.0;
			this->TW_Matrix[11] = 0.0;
			this->TW_Matrix[15] = 1.0;
		}

		/*
		 * Transpose the TW_Matrix
		 */
		void transpose() {
			ValueType temp[4][4];
			for (int y = 0; y < 4; y++)
				for (int x = 0; x < 4; x++)
					temp[x][y] = this->values[x][y];
			for (int y = 0; y < 4; y++)
				for (int x = 0; x < 4; x++)
					this->values[y][x] = temp[x][y];
		}

		void invert() {
			//
			this->transpose();
		}

		/*
		 * TW_Matrix multiplication
		 */
		ClassType operator * (const VectorTemplate <ValueType> &other) const {
			return
				VectorTemplate <ValueType> (
					other.x * this->values[0][0] + other.y * this->values[1][0] + other.z * this->values[2][0] + this->TW_Matrix[12],
					other.x * this->values[0][1] + other.y * this->values[1][1] + other.z * this->values[2][1] + this->TW_Matrix[13],
					other.x * this->values[0][2] + other.y * this->values[1][2] + other.z * this->values[2][2] + this->TW_Matrix[14]
				);
		}

		/*
		 * TW_Matrix multiplication with math::TW_Vector3
		 */
		VectorTemplate <ValueType> transform(const VectorTemplate <ValueType> &other) const {
			return
				VectorTemplate <ValueType> (
					other.x * this->values[0][0] + other.y * this->values[1][0] + other.z * this->values[2][0] + this->TW_Matrix[12],
					other.x * this->values[0][1] + other.y * this->values[1][1] + other.z * this->values[2][1] + this->TW_Matrix[13],
					other.x * this->values[0][2] + other.y * this->values[1][2] + other.z * this->values[2][2] + this->TW_Matrix[14]
				);
		}

		/*
		 * Reverse TW_Matrix multiplication with math::TW_Vector3
		 */
		VectorTemplate <ValueType> reverseTransform(const VectorTemplate <ValueType> &other) const {
			return
				VectorTemplate <ValueType> (
					other.x * this->values[0][0] + other.y * this->values[0][1] + other.z * this->values[0][2] - this->TW_Matrix[12],
					other.x * this->values[1][0] + other.y * this->values[1][1] + other.z * this->values[1][2] - this->TW_Matrix[13],
					other.x * this->values[2][0] + other.y * this->values[2][1] + other.z * this->values[2][2] - this->TW_Matrix[14]
				);
		}

		/*
		 * Reverse TW_Matrix multiplication with math::TW_Vector3
		 */
		VectorTemplate <ValueType> reverseRotate(const VectorTemplate <ValueType> &other) const {
			return
				VectorTemplate <ValueType> (
					other.x * this->values[0][0] + other.y * this->values[0][1] + other.z * this->values[0][2],
					other.x * this->values[1][0] + other.y * this->values[1][1] + other.z * this->values[1][2],
					other.x * this->values[2][0] + other.y * this->values[2][1] + other.z * this->values[2][2]
				);
		}


		/*
		 * Project
		 */
		VectorTemplate <ValueType> project(const VectorTemplate <ValueType> &TW_Vector3) const {
			VectorTemplate <ValueType> out;
			out.x = TW_Vector3.x * TW_Matrix[0] + TW_Vector3.y * TW_Matrix[4] + TW_Vector3.z * TW_Matrix[8] + TW_Matrix[12];
			out.y = TW_Vector3.x * TW_Matrix[1] + TW_Vector3.y * TW_Matrix[5] + TW_Vector3.z * TW_Matrix[9] + TW_Matrix[13];
			out.z = TW_Vector3.x * TW_Matrix[2] + TW_Vector3.y * TW_Matrix[6] + TW_Vector3.z * TW_Matrix[10] + TW_Matrix[14];
			ValueType t = 1.0 / (TW_Vector3.x * TW_Matrix[3] + TW_Vector3.y * TW_Matrix[7] + TW_Vector3.z * TW_Matrix[11] + TW_Matrix[15]);
			out *= t;
			return out;
		}

		/**
		 * Align rotation along a TW_Vector3
		 */
		void alignToVector(const VectorTemplate <ValueType> &dir, const VectorTemplate <ValueType> &_up) {
			VectorTemplate <ValueType> up = _up;
			VectorTemplate <ValueType> right = up.cross(dir);

			up = dir.cross(right);
			up.normalize();
			right.normalize();

			this->values[0][0] = right.x;
			this->values[0][1] = right.y;
			this->values[0][2] = right.z;
			//this->values[0][3] = 0;

			this->values[1][0] = up.x;
			this->values[1][1] = up.y;
			this->values[1][2] = up.z;
			//this->values[1][3] = 0;

			this->values[2][0] = dir.x;
			this->values[2][1] = dir.y;
			this->values[2][2] = dir.z;
			//this->values[2][3] = 0;

			//this->values[3][0] = 0;
			//this->values[3][1] = 0;
			//this->values[3][2] = 0;
			this->values[3][3] = 1;

		}

		/**
		 * Set translation
		 */
		void setTranslation(const VectorTemplate <ValueType> &TW_Vector3) {
			this->TW_Matrix[12] = TW_Vector3.x;
			this->TW_Matrix[13] = TW_Vector3.y;
			this->TW_Matrix[14] = TW_Vector3.z;
		}

		/**
		 * Set scale
		 */
		void scale(const VectorTemplate <ValueType> &TW_Vector3) {
			ClassType scale;
			scale.values[0][0] *= TW_Vector3.x;
			scale.values[1][1] *= TW_Vector3.y;
			scale.values[2][2] *= TW_Vector3.z;
			*this = *this * scale;
		}


};

#endif

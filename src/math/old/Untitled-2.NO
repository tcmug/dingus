#ifndef MATRIXTEMPLATE_HPP
#define MATRIXTEMPLATE_HPP

#include "vectortemplate.hpp"

template <typename type>
class MatrixTemplate {
	public:

		typedef type ValueType;
		typedef MatrixTemplate <type> ClassType;

		union {
			ValueType values[4][4];
			ValueType matrix[16];
		};

		MatrixTemplate() {
			this->identity();
		}

		/*
		 * Load an identity math::vector
		 */
		void identity() {
			this->matrix[0] = 1;
			this->matrix[1] = 0;
			this->matrix[2] = 0;
			this->matrix[3] = 0;

			this->matrix[4] = 0;
			this->matrix[5] = 1;
			this->matrix[6] = 0;
			this->matrix[7] = 0;

			this->matrix[8] = 0;
			this->matrix[9] = 0;
			this->matrix[10] = 1;
			this->matrix[11] = 0;

			this->matrix[12] = 0;
			this->matrix[13] = 0;
			this->matrix[14] = 0;
			this->matrix[15] = 1;
		}

		/*
		 * matrix multiplication
		 */
		ClassType operator * (const ClassType &other) const {

			ClassType result;

			result.matrix[0] = this->matrix[0]*other.matrix[0] + this->matrix[4]*other.matrix[1] + this->matrix[8]*other.matrix[2] + this->matrix[12]*other.matrix[3];
			result.matrix[1] = this->matrix[1]*other.matrix[0] + this->matrix[5]*other.matrix[1] + this->matrix[9]*other.matrix[2] + this->matrix[13]*other.matrix[3];
			result.matrix[2] = this->matrix[2]*other.matrix[0] + this->matrix[6]*other.matrix[1] + this->matrix[10]*other.matrix[2] + this->matrix[14]*other.matrix[3];
			result.matrix[3] = this->matrix[3]*other.matrix[0] + this->matrix[7]*other.matrix[1] + this->matrix[11]*other.matrix[2] + this->matrix[15]*other.matrix[3];

			result.matrix[4] = this->matrix[0]*other.matrix[4] + this->matrix[4]*other.matrix[5] + this->matrix[8]*other.matrix[6] + this->matrix[12]*other.matrix[7];
			result.matrix[5] = this->matrix[1]*other.matrix[4] + this->matrix[5]*other.matrix[5] + this->matrix[9]*other.matrix[6] + this->matrix[13]*other.matrix[7];
			result.matrix[6] = this->matrix[2]*other.matrix[4] + this->matrix[6]*other.matrix[5] + this->matrix[10]*other.matrix[6] + this->matrix[14]*other.matrix[7];
			result.matrix[7] = this->matrix[3]*other.matrix[4] + this->matrix[7]*other.matrix[5] + this->matrix[11]*other.matrix[6] + this->matrix[15]*other.matrix[7];

			result.matrix[8] = this->matrix[0]*other.matrix[8] + this->matrix[4]*other.matrix[9] + this->matrix[8]*other.matrix[10] + this->matrix[12]*other.matrix[11];
			result.matrix[9] = this->matrix[1]*other.matrix[8] + this->matrix[5]*other.matrix[9] + this->matrix[9]*other.matrix[10] + this->matrix[13]*other.matrix[11];
			result.matrix[10] = this->matrix[2]*other.matrix[8] + this->matrix[6]*other.matrix[9] + this->matrix[10]*other.matrix[10] + this->matrix[14]*other.matrix[11];
			result.matrix[11] = this->matrix[3]*other.matrix[8] + this->matrix[7]*other.matrix[9] + this->matrix[11]*other.matrix[10] + this->matrix[15]*other.matrix[11];

			result.matrix[12] = this->matrix[0]*other.matrix[12] + this->matrix[4]*other.matrix[13] + this->matrix[8]*other.matrix[14] + this->matrix[12]*other.matrix[15];
			result.matrix[13] = this->matrix[1]*other.matrix[12] + this->matrix[5]*other.matrix[13] + this->matrix[9]*other.matrix[14] + this->matrix[13]*other.matrix[15];
			result.matrix[14] = this->matrix[2]*other.matrix[12] + this->matrix[6]*other.matrix[13] + this->matrix[10]*other.matrix[14] + this->matrix[14]*other.matrix[15];
			result.matrix[15] = this->matrix[3]*other.matrix[12] + this->matrix[7]*other.matrix[13] + this->matrix[11]*other.matrix[14] + this->matrix[15]*other.matrix[15];

			return result;
		}

		/*
		 * Rotate matrix around its axes
		 */
		void rotate(ValueType psi, ValueType theta, ValueType phi) {
			ValueType ca = cos(phi), sa = sin(phi);
			ValueType cb = cos(theta), sb = sin(theta);
			ValueType cy = cos(psi), sy = sin(psi);

			this->matrix[0] = ca*cb;
			this->matrix[4] = ca*sb*sy - sa*cy;
			this->matrix[8] = ca*sb*cy + sa*sy;
			this->matrix[12] = 0.0;

			this->matrix[1] = sa*cb;
			this->matrix[5] = sa*sb*sy + ca*cy;
			this->matrix[9] = sa*sb*cy - ca*sy;
			this->matrix[13] = 0.0;

			this->matrix[2] = -sb;
			this->matrix[6] = cb*sy;
			this->matrix[10] = cb*cy;
			this->matrix[14] = 0.0;

			this->matrix[3] = 0.0;
			this->matrix[7] = 0.0;
			this->matrix[11] = 0.0;
			this->matrix[15] = 1.0;
		}

		/*
		 * Transpose the matrix
		 */
		void transpose() {
			ValueType temp[4][4];
			for (int y = 0; y < 4; y++)
				for (int x = 0; x < 4; x++)
					temp[x][y] = this->values[x][y];
			for (int y = 0; y < 4; y++)
				for (int x = 0; x < 4; x++)
					this->values[y][x] = temp[x][y];
		}

		void invert() {
			//
			this->transpose();
		}

		/*
		 * matrix multiplication
		 */
		ClassType operator * (const VectorTemplate <ValueType> &other) const {
			return
				VectorTemplate <ValueType> (
					other.x * this->values[0][0] + other.y * this->values[1][0] + other.z * this->values[2][0] + this->matrix[12],
					other.x * this->values[0][1] + other.y * this->values[1][1] + other.z * this->values[2][1] + this->matrix[13],
					other.x * this->values[0][2] + other.y * this->values[1][2] + other.z * this->values[2][2] + this->matrix[14]
				);
		}

		/*
		 * matrix multiplication with math::vector
		 */
		VectorTemplate <ValueType> transform(const VectorTemplate <ValueType> &other) const {
			return
				VectorTemplate <ValueType> (
					other.x * this->values[0][0] + other.y * this->values[1][0] + other.z * this->values[2][0] + this->matrix[12],
					other.x * this->values[0][1] + other.y * this->values[1][1] + other.z * this->values[2][1] + this->matrix[13],
					other.x * this->values[0][2] + other.y * this->values[1][2] + other.z * this->values[2][2] + this->matrix[14]
				);
		}

		/*
		 * Reverse matrix multiplication with math::vector
		 */
		VectorTemplate <ValueType> reverseTransform(const VectorTemplate <ValueType> &other) const {
			return
				VectorTemplate <ValueType> (
					other.x * this->values[0][0] + other.y * this->values[0][1] + other.z * this->values[0][2] - this->matrix[12],
					other.x * this->values[1][0] + other.y * this->values[1][1] + other.z * this->values[1][2] - this->matrix[13],
					other.x * this->values[2][0] + other.y * this->values[2][1] + other.z * this->values[2][2] - this->matrix[14]
				);
		}

		/*
		 * Reverse matrix multiplication with math::vector
		 */
		VectorTemplate <ValueType> reverseRotate(const VectorTemplate <ValueType> &other) const {
			return
				VectorTemplate <ValueType> (
					other.x * this->values[0][0] + other.y * this->values[0][1] + other.z * this->values[0][2],
					other.x * this->values[1][0] + other.y * this->values[1][1] + other.z * this->values[1][2],
					other.x * this->values[2][0] + other.y * this->values[2][1] + other.z * this->values[2][2]
				);
		}


		/*
		 * Project
		 */
		VectorTemplate <ValueType> project(const VectorTemplate <ValueType> &vector) const {
			VectorTemplate <ValueType> out;
			out.x = vector.x * matrix[0] + vector.y * matrix[4] + vector.z * matrix[8] + matrix[12];
			out.y = vector.x * matrix[1] + vector.y * matrix[5] + vector.z * matrix[9] + matrix[13];
			out.z = vector.x * matrix[2] + vector.y * matrix[6] + vector.z * matrix[10] + matrix[14];
			ValueType t = 1.0 / (vector.x * matrix[3] + vector.y * matrix[7] + vector.z * matrix[11] + matrix[15]);
			out *= t;
			return out;
		}

		/**
		 * Align rotation along a vector
		 */
		void alignToVector(const VectorTemplate <ValueType> &dir, const VectorTemplate <ValueType> &_up) {
			VectorTemplate <ValueType> up = _up;
			VectorTemplate <ValueType> right = up.cross(dir);

			up = dir.cross(right);
			up.normalize();
			right.normalize();

			this->values[0][0] = right.x;
			this->values[0][1] = right.y;
			this->values[0][2] = right.z;
			//this->values[0][3] = 0;

			this->values[1][0] = up.x;
			this->values[1][1] = up.y;
			this->values[1][2] = up.z;
			//this->values[1][3] = 0;

			this->values[2][0] = dir.x;
			this->values[2][1] = dir.y;
			this->values[2][2] = dir.z;
			//this->values[2][3] = 0;

			//this->values[3][0] = 0;
			//this->values[3][1] = 0;
			//this->values[3][2] = 0;
			this->values[3][3] = 1;

		}

		/**
		 * Set translation
		 */
		void setTranslation(const VectorTemplate <ValueType> &vector) {
			this->matrix[12] = vector.x;
			this->matrix[13] = vector.y;
			this->matrix[14] = vector.z;
		}

		/**
		 * Set scale
		 */
		void scale(const VectorTemplate <ValueType> &vector) {
			ClassType scale;
			scale.values[0][0] *= vector.x;
			scale.values[1][1] *= vector.y;
			scale.values[2][2] *= vector.z;
			*this = *this * scale;
		}


};

#endif
